/*
 * A Mojo grammar for ANTLR 4
 */

lexer grammar MojoLexer;

// Keywords
KEYWORD_AND       : 'and';
KEYWORD_AS        : 'as';
KEYWORD_ATTRIBUTE : 'attribute';
KEYWORD_BREAK     : 'break';
KEYWORD_CONST     : 'const';
KEYWORD_CONTINUE  : 'continue';
KEYWORD_ELSE      : 'else';
KEYWORD_ENUM      : 'enum';
KEYWORD_FALSE     : 'false';
KEYWORD_FOR       : 'for';
KEYWORD_FUNC      : 'func';
KEYWORD_IF        : 'if';
KEYWORD_IMPORT    : 'import';
KEYWORD_IN        : 'in';
KEYWORD_INTERFACE : 'interface';
KEYWORD_IS        : 'is';
KEYWORD_MATCH     : 'match';
KEYWORD_NOT       : 'not';
KEYWORD_NULL      : 'null';
KEYWORD_OR        : 'or';
KEYWORD_PACKAGE   : 'package';
// KEYWORD_REPEAT    : 'repeat';
KEYWORD_RETURN    : 'return';
KEYWORD_STRUCT    : 'struct';       // reserved
KEYWORD_TRUE      : 'true';
KEYWORD_TYPE      : 'type';
KEYWORD_VAR       : 'var';
KEYWORD_WHILE     : 'while';
KEYWORD_XOR       : 'xor';


// Punctuation

DOT    	: '.' ;
LCURLY 	: '{' ;
LPAREN 	: '(' ;
LBRACK 	: '[' ;
RCURLY 	: '}' ;
RPAREN 	: ')' ;
RBRACK 	: ']' ;
COMMA  	: ',' ;
COLON  	: ':' ;
SEMI   	: ';' ;
LT 		: '<' ;
GT 		: '>' ;
BANG 	: '!' ;
QUESTION: '?' ;
AT 		: '@' ;
AND 	: '&' ;
MINUS 	: '-' ;
EQUAL 	: '=' ;
PIPE 	: '|' ;
SLASH 	: '/' ;
PLUS 	: '+' ;
STAR 	: '*' ;
PERCENT : '%' ;
CARET 	: '^' ;
TILDE 	: '~' ;
DOLLAR  : '$' ;
BACKTICK: '`' ;
UNDERSCORE : '_' ;

PLUS_PLUS   : '+''+';
MINUS_MINUS : '-''-';

COLON_EQUAL : ':' '=';

RIGHT_RIGHT_ARROWS : '=' '>';
RIGHT_ARROW : '-' '>';

DOT_DOT    : '.' '.';
DOT_DOT_LT : '.' '.' '<';

ELLIPSIS : '.' '.' '.';

GRAPH_RIGHT_PATH : ')' '-' '-' '>' '(';
GRAPH_LEFT_PATH : ')' '<' '-' '-' '(';
GRAPH_PATH: ')' '-' '-' '(';
GRAPH_CONSTRAINT_PATH_LEFT: ')' '-' '[';
GRAPH_CONSTRAINT_PATH_LEFT_ARROW: ')' '<' '-' '[';
GRAPH_CONSTRAINT_PATH_RIGHT: ']' '-' '(';
GRAPH_CONSTRAINT_PATH_RIGHT_ARROW: ']' '-' '>' '(';

TYPE_IDENTIFIER
 : [A-Z][a-zA-Z0-9]*
;

VALUE_IDENTIFIER
 : VALUE_IDENTIFIER_HEAD VALUE_IDENTIFIER_CHARACTERS?
;

fragment VALUE_IDENTIFIER_HEAD
 : [a-z]
 | '\u00A8' | '\u00AA' | '\u00AD' | '\u00AF' | [\u00B2-\u00B5] | [\u00B7-\u00BA]
 | [\u00BC-\u00BE] | [\u00C0-\u00D6] | [\u00D8-\u00F6] | [\u00F8-\u00FF]
 | [\u0100-\u02FF] | [\u0370-\u167F] | [\u1681-\u180D] | [\u180F-\u1DBF]
 | [\u1E00-\u1FFF]
 | [\u200B-\u200D] | [\u202A-\u202E] | [\u203F-\u2040] | '\u2054' | [\u2060-\u206F]
 | [\u2070-\u20CF] | [\u2100-\u218F] | [\u2460-\u24FF] | [\u2776-\u2793]
 | [\u2C00-\u2DFF] | [\u2E80-\u2FFF]
 | [\u3004-\u3007] | [\u3021-\u302F] | [\u3031-\u303F] | [\u3040-\uD7FF]
 | [\uF900-\uFD3D] | [\uFD40-\uFDCF] | [\uFDF0-\uFE1F] | [\uFE30-\uFE44]
 | [\uFE47-\uFFFD]
 ;

fragment VALUE_IDENTIFIER_CHARACTER : [0-9A-Z_]
 | [\u0300-\u036F] | [\u1DC0-\u1DFF] | [\u20D0-\u20FF] | [\uFE20-\uFE2F]
 | VALUE_IDENTIFIER_HEAD
 ;

fragment VALUE_IDENTIFIER_CHARACTERS : VALUE_IDENTIFIER_CHARACTER+ ;

OPERATOR_HEAD_OTHER // valid operator chars not used by Swift itself
  : [\u00A1-\u00A7]
  | [\u00A9\u00AB]
  | [\u00AC\u00AE]
  | [\u00B0-\u00B1\u00B6\u00BB\u00BF\u00D7\u00F7]
  | [\u2016-\u2017\u2020-\u2027]
  | [\u2030-\u203E]
  | [\u2041-\u2053]
  | [\u2055-\u205E]
  | [\u2190-\u23FF]
  | [\u2500-\u2775]
  | [\u2794-\u2BFF]
  | [\u2E00-\u2E7F]
  | [\u3001-\u3003]
  | [\u3008-\u3030]
  ;

IMPLICIT_PARAMETER_NAME : DOLLAR PURE_DECIMAL_DIGITS ;

BINARY_LITERAL : '0b' BINARY_DIGIT BINARY_LITERAL_CHARACTERS? ;
fragment BINARY_DIGIT : [01] ;
fragment BINARY_LITERAL_CHARACTER : BINARY_DIGIT | '_'  ;
fragment BINARY_LITERAL_CHARACTERS : BINARY_LITERAL_CHARACTER+ ;

OCTAL_LITERAL : '0o' OCTAL_DIGIT OCTAL_LITERAL_CHARACTERS? ;
fragment OCTAL_DIGIT : [0-7] ;
fragment OCTAL_LITERAL_CHARACTER : OCTAL_DIGIT | '_'  ;
fragment OCTAL_LITERAL_CHARACTERS : OCTAL_LITERAL_CHARACTER+ ;

DECIMAL_LITERAL		: [0-9] [0-9_]* ;
PURE_DECIMAL_DIGITS   : [0-9]+ ;
fragment DECIMAL_DIGIT : [0-9] ;
fragment DECIMAL_LITERAL_CHARACTER : DECIMAL_DIGIT | '_'  ;
fragment DECIMAL_LITERAL_CHARACTERS : DECIMAL_LITERAL_CHARACTER+ ;

HEXADECIMAL_LITERAL : '0x' HEXADECIMAL_DIGIT HEXADECIMAL_LITERAL_CHARACTERS? ;
fragment HEXADECIMAL_DIGIT : [0-9a-fA-F] ;
fragment HEXADECIMAL_LITERAL_CHARACTER : HEXADECIMAL_DIGIT | '_'  ;
fragment HEXADECIMAL_LITERAL_CHARACTERS : HEXADECIMAL_LITERAL_CHARACTER+ ;

// GRAMMAR OF A FLOATING_POINT LITERAL

FLOAT_LITERAL
 : DECIMAL_LITERAL DECIMAL_FRACTION? DECIMAL_EXPONENT?
 | HEXADECIMAL_LITERAL HEXADECIMAL_FRACTION? HEXADECIMAL_EXPONENT
 ;

fragment DECIMAL_FRACTION : '.' DECIMAL_LITERAL ;
fragment DECIMAL_EXPONENT : FLOATING_POINT_E SIGN? DECIMAL_LITERAL ;
fragment HEXADECIMAL_FRACTION : '.' HEXADECIMAL_DIGIT HEXADECIMAL_LITERAL_CHARACTERS? ;
fragment HEXADECIMAL_EXPONENT : FLOATING_POINT_P SIGN? DECIMAL_LITERAL ;
fragment FLOATING_POINT_E : [eE] ;
fragment FLOATING_POINT_P : [pP] ;
fragment SIGN : [+\-] ;

STATIC_STRING_LITERAL
    : '"' DOUBLE_QUOTED_TEXT? '"'
    | '\'' SINGLE_QUOTED_TEXT? '\''
    ;

fragment DOUBLE_QUOTED_TEXT : DOUBLE_QUOTED_TEXT_ITEM+ ;
fragment SINGLE_QUOTED_TEXT : SINGLE_QUOTED_TEXT_ITEM+ ;

fragment
DOUBLE_QUOTED_TEXT_ITEM
  : ESCAPED_CHARACTER
  | ~["\n\r\\]
  ;

fragment
SINGLE_QUOTED_TEXT_ITEM
  : ESCAPED_CHARACTER
  | ~['\n\r\\]
  ;

fragment
ESCAPED_CHARACTER
  : '\\' [0\\tnr"']
  | '\\x' HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT
  | '\\u' HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT
  | '\\u' '{' HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT '}'
  | '\\u' '{' HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT '}'
  ;

INTERPOLATED_STRING_LITERAL
  : '"' DOUBLE_INTERPOLATED_TEXT_ITEM* '"'
  | '\'' SINGLE_INTERPOLATED_TEXT_ITEM* '\''
  ;

fragment
DOUBLE_INTERPOLATED_TEXT_ITEM
  : '\\{' (INTERPOLATED_STRING_LITERAL | DOUBLE_INTERPOLATED_TEXT_ITEM)+ '}' // nested strings allowed
  | DOUBLE_QUOTED_TEXT_ITEM
  ;

fragment
SINGLE_INTERPOLATED_TEXT_ITEM
  : '\\{' (INTERPOLATED_STRING_LITERAL | SINGLE_INTERPOLATED_TEXT_ITEM)+ '}' // nested strings allowed
  | SINGLE_QUOTED_TEXT_ITEM
  ;

WS
  : [\u0020\u0009\u000B\u000C\u0000]
  -> channel(HIDDEN) ;

BLOCK_COMMENT
  : '/*' (BLOCK_COMMENT|.)*? '*/'
  -> channel(HIDDEN)
  ; // nesting comments allowed

LINE_COMMENT
  : '//' (~[/<\u000A\u000D] ~[\u000A\u000D]*)?
  -> channel(HIDDEN)
  ;

LINE_COMMENT_DISTINCT_DOCUMENT
  : '////' ~[\u000A\u000D]*
  -> channel(HIDDEN)
  ;

EOL   : '\u000A' | '\u000D' '\u000A'; // \r\n

LINE_DOCUMENT : '///' (~[/<\u000A\u000D] ~[\u000A\u000D]*)?;
FOLLOWING_LINE_DOCUMENT : '//<' ~[\u000A\u000D]*;
INNER_LINE_DOCUMENT : '//!' ~[\u000A\u000D]*;

//fragment
OPERATOR_FOLLOWING_CHARACTER
  : [\u0300-\u036F]
  | [\u1DC0-\u1DFF]
  | [\u20D0-\u20FF]
  | [\uFE00-\uFE0F]
  | [\uFE20-\uFE2F]
  //| [\uE0100-\uE01EF]  ANTLR can't do >16bit char
  ;
